#!/usr/bin/env python3
"""
Reads csv file FILENAME.csv separated by "," generated by AMC in "0;1;0;1;1;0" mode.
File must have columns MANDATORY_COLUMNS (Exam, A:Matricule, Name, Mark, zmatr, zmatr[*]).
All questions that starts with QF (Question FermÃ©es) will be transformed into numerical value.

Generates FILENAME_numerical_values.xslx and .csv
"""

import csv
import sys, os
import argparse
from pprint import pprint # for debugging

assert sys.version_info[0] >= 3, "Python 3 please"

p = argparse.ArgumentParser()

p.add_argument('filename')
# p.add_argument('--policy', action='append', dest='policies', choices={'EmptyColumnMeansFirstTicked', 'NoSignMeansPlus'}, default=['EmptyColumnMeansFirstTicked'])

a = args = p.parse_args()

FILENAME = args.filename # 'generateurAMC_B.csv'
POLICIES = {'EmptyColumnMeansFirstTicked'} & {'EmptyColumnMeansFirstTicked', 'NoSignMeansPlus'} # set(args.policies)

assert FILENAME.endswith('.csv')

if os.name == 'nt': # and not args.win_no_cd:
    os.chdir(os.path.dirname(sys.argv[0]) or '.') # we right clicked on the file, so cd into the directory of the file

with open(FILENAME) as f:
    csvMatrix = list(csv.DictReader(f))

if not csvMatrix:
    print('Empty csv')
    sys.exit(1)
    
## BEGIN natsort ##
try:
    from natsort import natsort_keygen
    key_natural_sort = natsort_keygen()
except ImportError:
  def key_natural_sort(filename):
    """
    >>> key_natural_sort('File 28 Page 2')
    ['File ', '0000000028', ' Page ', '0000000002']
    
    >>> sorted(['1.png', '2.png', '3.png', '10.png', '20.png'], key=key_natural_sort)
    ['1.png', '2.png', '3.png', '10.png', '20.png']
    
    """
    return [
        x if x else y.zfill(10) # int(y)
        for x,y in re.compile('([^\\d]+)|(\\d+)').findall(filename)
    ]
## END natsort ##

MANDATORY_COLUMNS = {'Exam', 'A:Matricule', 'Name', 'Mark', 'zmatr'} | {'zmatr[{}]'.format(i) for i in (1,2,3,4,5,6)}
FIELDS = set(csvMatrix[0].keys()) # DictReader enforces that all(l.keys() == FIELDS for l in csvMatrix)

assert MANDATORY_COLUMNS <= FIELDS, "Missing columns: {}".format(MANDATORY_COLUMNS - FIELDS)

Questions = {f for f in FIELDS - MANDATORY_COLUMNS if not f.startswith('TICKED:')}

class EmptyColumn(Exception):
    pass

class MultipleTicksInColumn(Exception):
    pass

def parseQF(csvLine:list, name:'QF1b', *, base=10, policies=POLICIES):
    def parsePart(part:'digits|exp', expectedNumbers:3, *, base=base, hasSign=True, direction:'plus|minus'='plus'):
        """
        Parse a signed number.
        if hasSign, the first two boxes contains the sign (first = +, second = -).
        Then we have base=10 expectedNumbers boxes representing numbers. For example expectedNumbers = 3, digits = [6,0,9].
        If direction == "plus" Then Digits represents 609
        If direction == "minus" Then Digits represents 6.09
        """
        assert part in ('digits', 'exp') and direction in ('plus', 'minus')
    
        field = 'TICKED:{}{}'.format(name, part)
        Ticks = list(map(int, csvLine[field.format(name)].split(';')))
        
        # Example: Ticks = [0,1, 0,0,0,1,0,0,0,0,0,0, 0,1,0,0,0,0,0,0,0,0]
        
        assert len(Ticks) == (2 if hasSign else 0) + expectedNumbers * base
        
        if hasSign:
            Sign = Ticks[0:2]
            Digits = [Ticks[2+n : 2+n+base] for n in range(0, base * expectedNumbers, base)]
        else:
            Sign = [1,0] # Positive
            Digits = [Ticks[n : n+base] for n in range(0, base * expectedNumbers, base)]
        
        if Sign == [0,0] and 'NoSignMeansPlus' in policies:
            Sign = [1,0]
        
        # Example if hasSign == True and base == 10: Sign = [0,1]; Digits = [[0,0,0,1,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0]]
        
        for col in [Sign] + Digits:
            if sum(col) == 0:
                if 'EmptyColumnMeansFirstTicked' in policies:
                    col[0] = 1
                else:
                    raise EmptyColumn("User ticked zero columns in a column (for {})".format(part))
            if sum(col) > 1:
                raise MultipleTicksInColumn("User ticked two columns in a column (for {})".format(part))
        
        sign = +1 if Sign[0] else -1
        digits = [D.index(1) for D in Digits]
        
        # Example: sign = -1; digits = [3, 1]
        
        number = (sign * sum(n * base ** (-i) for i,n in enumerate(digits)) if direction == 'minus' else
                  sign * sum(n * base ** i for i,n in enumerate(reversed(digits))) if direction == 'plus' else None)
    
        # Example if direction == 'minus': number = -3.1
        # Example if direction == 'plus':  number = -31
        
        return number
    
    number = parsePart('digits', 3, hasSign=True, direction='minus')
    numberExp = parsePart('exp', 1, hasSign=True, direction='plus')
    numberFinal = number * base ** numberExp
    
    return {'value': numberFinal, 'mantissa':number, 'exp':numberExp, 'sign': 0 if numberFinal == 0 else -1 if numberFinal < 0 else 1}

ClosedQuestionsColumns = {q for q in Questions if q.startswith('QF')}
OpenedQuestionsColumns = Questions - ClosedQuestionsColumns

assert all(c.endswith('digits') or c.endswith('exp') for c in ClosedQuestionsColumns)
for a,b in (('digits', 'exp'), ('exp', 'digits')):
    assert all(c[:-len(a)] + b in ClosedQuestionsColumns
               for c in ClosedQuestionsColumns
               if c.endswith(a))

ClosedQuestions = {c[:-len('digits')] for c in ClosedQuestionsColumns if c.endswith('digits')}

def parseFrenchNumber(string):
    """
    >>> parseFrenchNumber('1,5')
    1.5
    """
    if string.count(',') == 0:
        return float(string)
    if string.count(',') > 1:
        raise ValueError('Number has more than one virgule')
    return float('.'.join(string.split(',')))

print('ClosedQuestions', ClosedQuestions)

sorted_natsort = lambda X: sorted(X, key=key_natural_sort)
flatten = lambda X: [y for x in X for y in x]

QF_DETAILS = True
QF_FIELDS = 'value mantissa exp sign'.split()

for USE_XL in (False, True):

    out_filename = FILENAME[:-4] + '_numerical_values' + ('.xslx' if USE_XL else '.csv')

    if USE_XL:
        try:
            import openpyxl
        except ImportError:
            print('[WARNING] openpyxl not installed, no xslx generated.')
            continue

        wb = openpyxl.Workbook()

        def writerow(row):
            wb.active.append(row)
        
        def close():
            wb.save(out_filename)
            
    else:
        f = open(out_filename, 'w')
        writer = csv.writer(f)
        
        def writerow(row):
            writer.writerow(row)
        
        def close():
            f.close()

    try:
        writerow([
            'Exam',
            'A:Matricule',
            'Name',
            ] + flatten([
                [q + ('_' + key) * (key != 'value') for key in QF_FIELDS]
                for q in sorted_natsort(ClosedQuestions)
            ]) + flatten([
                [q, 'TICKED:' + q]
                for q in sorted_natsort(OpenedQuestionsColumns)
            ]))
        
        for student in csvMatrix[:2]:
            
            answers = {}
            
            for q in sorted_natsort(ClosedQuestions):
                try:
                    answers[q] = parseQF(student, q)
                except Exception as e:
                    answers[q] = e
            
            # pprint([student['A:Matricule'], 'has', answers])
            
            writerow([
                student['Exam'],
                student['A:Matricule'],
                student['Name'],
            ] + flatten([
                [answers[q][key] for key in QF_FIELDS]
                if not isinstance(answers[q], Exception) else
                [str(answers[q].__class__.__name__)] * bool(QF_FIELDS) + ['NA'] * (len(QF_FIELDS) - 1)
                
                for q in sorted_natsort(ClosedQuestions)
            ]) + flatten([
                [parseFrenchNumber(student[q]),
                 student['TICKED:' + q]]
                for q in sorted_natsort(OpenedQuestionsColumns)
            ]))
    finally:
        close()

    print('Generated', out_filename)

if os.name == 'nt':    
    os.system('pause')
